# -*- coding: utf-8 -*-
"""Pandas_Hands_on.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nE4cnuA4PNoKUCP9ISOmE24QzhdQic8g
"""

!jupyter nbconvert --to script '/content/your_notebook.ipynb'

"""# Pandas Tutorial


---

This notebook serves as an introduction to the essential data structures offered by the **Pandas** library, a cornerstone tool in the Python data science ecosystem.

Built on top of NumPy, Pandas provides a highly efficient and flexible implementation of **DataFrames**—two-dimensional, labeled data structures that support heterogeneous data types and gracefully handle missing values. These DataFrames enable powerful data manipulation capabilities through intuitive and high-level operations.

Throughout this notebook, we will use the standard alias `pd` when importing Pandas.
"""

import pandas as pd
import numpy as np

"""## Pandas Series


A Pandas `Series` is a one-dimensional array of indexed data.
"""

data = pd.Series([0.25, 0.5, 0.75, 1.0])
data

"""The contents can be accessed in the same way as for NumPy arrays, to the difference that when more than one value is selected, the type remains a Pandas ``Series``."""

print(data[0],type(data[0]))

print(data[2:],type(data[2:]))

"""The type ``Series`` wraps both a sequence of values and a sequence of indices, which we can access with the <tt>values</tt> and <tt>index</tt> attributes.

* ``values`` are the contents of the series as a NumPy array
"""

print(data.values,type(data.values))

"""* ``index`` are the indices of the series"""

print(data.index,type(data.index))

"""### Series Indices

The main difference between NumPy arrays and Pandas Series is the presence of this <tt>index</tt> field. By default, it is set (as in NumPy arrays) as <tt>0,1,..,size_of_the_series</tt> but a Series index can be explicitly defined. The indices may be numbers but also strings. Then, the contents of the series *have to* be accessed using these defined indices.
"""

data = pd.Series([0.25, 0.5, 0.75, 1.0], index=['a', 'b', 'c', 'd'])
print(data)

print(data['c'])

data = pd.Series([0.25, 0.5, 0.75, 1.0], index=[1, 3, 4, 2])
print(data)

print(data[2])

"""### Series and Python Dictionaries

Pandas Series and Python Dictionaries are close semantically: mappping keys to values. However, the implementation of Pandas series is usually more efficient than dictionaries in the context of data science. Naturally, Series can be contructed from dictionaries.
"""

population_dict = {'California': 38332521,
                   'Texas': 26448193,
                   'New York': 19651127,
                   'Florida': 19552860,
                   'Illinois': 12882135}
population = pd.Series(population_dict)
print(population_dict,type(population_dict))
print(population,type(population))

population['California']

population['California':'Illinois']

"""## Pandas DataFrames

DataFrames is a fundamental object of Pandas that mimicks what can be found in `R` for instance. Dataframes can be seen as an array of Series: to each `index` (corresponding to an individual for instance or a line in a table), a Dataframe maps multiples values; these values corresponds to the `columns` of the DataFrame which each have a name (as a string).   


In the following example, we will construct a Dataframe from two Series with common indices.
"""

area = pd.Series( {'California': 423967, 'Texas': 695662, 'New York': 141297, 'Florida': 170312, 'Illinois': 149995})
population = pd.Series({'California': 38332521, 'Texas': 26448193, 'New York': 19651127, 'Florida': 19552860, 'Illinois': 12882135})

states = pd.DataFrame({'Population': population, 'Area': area})
print(states,type(states))

"""In Jupyter notebooks, DataFrames are displayed in a fancier way when the name of the dataframe is typed (instead of using <tt>print</tt>)"""

states

"""DataFrames have
* <tt>index</tt> that are the defined indices as in Series
* <tt>columns</tt> that are the columns names
* <tt>values</tt> that return a (2D) NumPy array with the contents
"""

print(states.index)
print(states.columns)
print(states.values,type(states.values),states.values.shape)

"""*Warning:*  When accessing a Dataframe, `dataframe_name[column_name]` return the corresponding column as a Series. `dataframe_name[index_name]` returns an error! We will see later how to access a specific index."""

print(states['Area'],type(states['Area']))

try:
    print(states['California'])
except KeyError as error:
    print("KeyError: ",error)

"""### Dataframe creation

To create DataFrames, the main methods are:
* from Series (as above)
"""

print(population,type(population))
states = pd.DataFrame({'Population': population, 'Area': area})
states

"""* from NumPy arrays (the columns and indices are taken as the array's ones)"""

A = np.random.randn(5,3)
print(A,type(A))
dfA = pd.DataFrame(A)
dfA

"""* from a *list* of *dictionaries*. Be careful, each element of the list is an example (corresponding to an automatic index 0,1,...) while each key of the dictonary corresponds to a column."""

data = [{'a': i, 'b': 2 * i} for i in range(3)]
print(data,type(data))
print(data[0],type(data[0]))

df = pd.DataFrame(data)
df

"""* from a *file* , typically a <tt>csv</tt> file (for comma separated values), eventually with the names of the columns as a first line.


    col_1_name,col_2_name,col_3_name
    col_1_v1,col_2_v1,col_3_v1
    col_1_v2,col_2_v2,col_3_v2
    ...
    
For other files types (MS Excel, libSVM, any other separator) see this [part of the doc](https://pandas.pydata.org/pandas-docs/stable/api.html#input-output)
"""

!head -4 data/president_heights.csv # bash command to see the first 4 lines of the file

data = pd.read_csv('data/president_heights.csv')
data

# @title order vs height(cm)

from matplotlib import pyplot as plt
import seaborn as sns
def _plot_series(series, series_name, series_index=0):
  palette = list(sns.palettes.mpl_palette('Dark2'))
  xs = series['order']
  ys = series['height(cm)']

  plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')
df_sorted = data.sort_values('order', ascending=True)
_plot_series(df_sorted, '')
sns.despine(fig=fig, ax=ax)
plt.xlabel('order')
_ = plt.ylabel('height(cm)')

"""### Names and Values

Notice there can be missing values in DataFrames.
"""

pd.DataFrame([{'a': 1, 'b': 2}, {'b': 3, 'c': 4}])

"""You can set indices and columns names *a posteriori*"""

dfA.columns = ['a','b','c']
dfA.index = [i**2 for i in range(1,6)  ]
dfA

"""## Indexing



"""

area = pd.Series( {'California': 423967, 'Texas': 695662, 'New York': 141297, 'Florida': 170312, 'Illinois': 149995})
population = pd.Series({'California': 38332521, 'Texas': 26448193, 'New York': 19651127, 'Florida': 19552860, 'Illinois': 12882135})
states = pd.DataFrame({'Population': population, 'Area': area})
states

# @title Population vs Area

from matplotlib import pyplot as plt
states.plot(kind='scatter', x='Population', y='Area', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

"""You may access columns directly with names, *then* you can access individuals with their index."""

states['Area']

states['Area']['Texas']

"""To ease the access, Pandas offers dedicated methods:
* <tt>iloc</tt> enables to access subparts of the dataframe as if it was a NumPy array.
"""

states.iloc[:2]

states.iloc[:2,0]

"""* <tt>loc</tt> does the same but with the explicit names (the last one is included)"""

states.loc[:'New York']

states.loc[:,'Population':]

"""## Questions and Exercises

**1. Series:**
   - Create a Pandas Series with the following data: [10, 20, 30, 40, 50].
   - Access the third element of the Series.
   - What is the data type of the Series?

**2. DataFrames:**
   - Create a Pandas DataFrame with two columns: 'Name' and 'Age'.
   - Add three rows to the DataFrame with the following data:
     - Name: 'Alice', Age: 25
     - Name: 'Bob', Age: 30
     - Name: 'Charlie', Age: 35
   - Access the 'Age' column of the DataFrame.
   - What is the shape of the DataFrame?

**3. Indexing:**
   - Using the DataFrame from question 2, access the row with the name 'Bob' using `loc`.
   - Access the age of 'Alice' using `iloc`.

**4. File I/O:**
   - Read the 'president_heights.csv' file into a DataFrame.
   - What is the average height of the presidents?
   - What is the name of the tallest president?

**5. Advanced:**
   - Create a DataFrame with three columns: 'A', 'B', and 'C'.
   - Fill the DataFrame with random numbers.
   - Calculate the mean of each column.
   - Add a new column 'D' which is the sum of columns 'A' and 'B'.
   - Sort the DataFrame by column 'D' in descending order.
"""

import pandas as pd
import numpy as np

# 1. Series
series = pd.Series([10, 20, 30, 40, 50])
third_element = series[2]
series_type = type(series)

# 2. DataFrames
data = {'Name': ['Alice', 'Bob', 'Charlie'], 'Age': [25, 30, 35]}
df = pd.DataFrame(data)
age_column = df['Age']
df_shape = df.shape

# 3. Indexing
row_bob = df.loc[df['Name'] == 'Bob']
age_alice = df.iloc[0]['Age']

# 4. File I/O
heights_df = pd.read_csv('president_heights.csv')
average_height = heights_df['height(cm)'].mean()
tallest_president = heights_df.loc[heights_df['height(cm)'].idxmax()]['name']
print("Average height of the presidents:", average_height)
print("Tallest president:", tallest_president)
# 5. Advanced
random_df = pd.DataFrame(np.random.rand(5, 3), columns=['A', 'B', 'C'])
column_means = random_df.mean()
random_df['D'] = random_df['A'] + random_df['B']
sorted_df = random_df.sort_values(by='D', ascending=False)

third_element, series_type, age_column, df_shape, row_bob, age_alice, average_height, tallest_president, column_means, sorted_df